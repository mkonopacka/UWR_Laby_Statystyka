---
title: "Statystyka - Laboratorium 4"
author: "Martyna Konopacka"
output: pdf_document
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
```

### Wprowadzenie i cele

Poniższe sprawozdanie jest kontynuacją sprawozdania z listy 3 - celem ponownie jest skonfrontowanie teoretycznych przedziałów ufności z wyznaczonymi eksperymentalnie, ale tym razem będą one liczone dla różnych funkcji parametrów, m.in. dla różnicy dwóch średnich. Przedziały ufności ponownie zostaną wyznaczone w oparciu o CTG. W zadaniach testowane są próby o liczebności 20, 50, 100 i dodatkowo 1000.

### Zadanie 1
Niech $\theta = \mu_1 - \mu_2$ i $\hat\theta = \hat{X_1} - \hat{X_2}$. Wiadomo, że $\hat\mu_i \sim N(\mu_i, \sigma_i^2)$ dla $i = 1,2$, stąd $\hat\theta \sim N(\theta, \sigma_1^2 + \sigma_2^2)$. Przekształcając podobnie jak na poprzedniej liście wyznaczymy przedział ufności postaci 
$$1 - \alpha = P(\hat\theta - z \frac{\sqrt{\sigma_1^2 + \sigma_2^2}}{\sqrt{n}} \leq \theta \leq \hat\theta + z \frac{\sqrt{\sigma_1^2 + \sigma_2^2}}{\sqrt{n}})$$
gdzie $z$ jest kwantylem na poziomie $p = 1 - \frac{\alpha}{2}$ z rozkładu standardowego. (Przykładowo, gdy poziom ufności $1- \alpha$ wynosi 0.95, to bierzemy kwantyl $p = 1 - \frac{0.05}{2} = 1 - 0.025 = 0.975$, który wynosi $1.96$). Uwaga: zakładamy, że próby są tej samej liczebności $n$.

```{r}
library(tidyverse)
library(stats)

# helper
printf <- function(str, ...){
  output <- sprintf(str, ...)
  cat(output)
}

# zwraca wektor postaci c(low,high), gdzie low i high są wartościami brzegowymi przedziału ufności dla różnicy średnich na poziomie lvl dla prób X1, X2 o liczebności n, pochodzącej z rozkładów o znanych odchyleniach std. s1, s2
i1 <- function(X1, X2, s1, s2, lvl = 0.95){
  # lenght(X1) == lenght(X2)
  n = length(X1)
  alpha = 1 - lvl
  z = qnorm(1 - alpha/2) # 1.96
  th = mean(X1) - mean(X2)
  sd = sqrt(s1^2 + s2^2)
  low = th - sd / sqrt(n) * z
  high =  th + sd / sqrt(n) * z
  return(c(low, high))
}

# funckja do testowania czy ok, gdzie podaje się same parametry a nie próbę
i1_par <- function(n,m1,m2,s1,s2,lvl = 0.95){
  alpha = 1 - lvl
  z = qnorm(1 - alpha/2)
  th = m1 - m2
  sd = sqrt(s1^2 + s2^2)
  low = th - sd / sqrt(n) * z
  high =  th + sd / sqrt(n) * z
  return(c(low, high))
}
```

```{r}
# zwraca wynik eksperymentu dla parametrów m1, m2, p1, p2. Funkcja została uogólniona do innych zadań: pop_param decyduje czy znamy drugi parametr populacji, a mode co szacujemy
f <- function(m1, s1, m2, s2, rvs = rnorm, n = 1000, lvl = 0.95, iter = 1000, seed = 1, mode = 'mdf', pop_param = TRUE, debug = FALSE){ 
   set.seed(seed)
   inside = 0
   # zapamiętanie parametrów przed przeliczeniem ich na w. oczekiwaną i sd --------
   m1o = m1
   m2o = m2
   s1o = s1
   s2o = s2
   
    # przeliczanie parametrów na wart. oczekiwaną i odchylenie -------------
   name = as.character(substitute(rvs))
   if (debug == TRUE){printf('name: %s', name)}
   if (name == 'rlogis'){
     s1 <- s1 * pi/sqrt(3)
     s2 <- s2 * pi/sqrt(3)
   }
 
   if (debug == TRUE){printf('m1: %s, s1: %s, m2: %s, s2: %s', m1, s1, m2, s2)}
   # iteracje ----------------------------
   for(i in 1:iter){
       X1 <- rvs(n, m1o, s1o)
       X2 <- rvs(n, m2o, s2o)
       if (debug == TRUE){
         printf('X1 mean: %s, X2 mean: %s \n', mean(X1), mean(X2))} 
       
     # co szacujemy i czy znamy drugi parametr?
     # MEANS DIFFERENCE -------------------------------------------------------
     if (mode == 'mdf'){
       mdf = m1 - m2
       # 1 
       if (pop_param == TRUE){interv = i1(X1, X2, s1, s2, lvl)}
       else {return()}
       increment = (mdf >= interv[1] & mdf <= interv[2])
       if (debug == TRUE){printf('interval: (%s, %s) %s\n', interv[1], interv[2], increment)}
       # czy prawdziwa różnica średnich leży w szacowanym na podstawie próby przedziale?
       if(increment){inside = inside + 1}
     } # end mode means_diff
   
       } # end iterations loop
   
   return(data.frame(rozklad = factor(name),
                     est = factor(mode),
                     n = factor(n),
                     m1 = factor(m1o),
                     m2 = factor(m2o),
                     s1 = factor(s1o),
                     s2 = factor(s2o),
                     wynik = inside/iter,
                     pop_param_known = pop_param,
                     iter = iter))
}
```

### Zadanie 2
```{r}
# zad2.results <- rbind(zad2.results, f(0,1,0,1), f(0,1,1,1), f(0,1,0,2),f(0,1,1,2),
#                       f(0,1,0,1,rlogis), f(0,1,1,1,rlogis),f(0,1,0,2,rlogis),f(0,1,1,2,rlogis),f(0,1,0,1,rcauchy),
# f(0,1,1,1,rcauchy),f(0,1,0,2,rcauchy),f(0,1,1,2,rcauchy))
# wyniki zapisane i załadowane
load('results/zad2.results')

zad2.results %>% 
  filter(rozklad != 'rcauchy') %>%
  mutate(params = factor(paste(m1, s1, m2, s2, sep = ', '))) %>%
  group_by(n) %>%
  ggplot(aes(x = n, y = wynik, fill = params)) +
  geom_bar(stat = 'identity', position = position_dodge()) +
  labs(title = 'Zadanie 2 - wyniki dla rozkladu normalnego i logistycznego', subtitle = 'Procent roznic srednich pokrytych przez przedzial ufnosci na poziomie 95%', x = 'n', y = '', fill = 'Parametry') +
  scale_fill_brewer(palette="Set1") +
  geom_hline(yintercept = 0.95, color = 'navy') +
  coord_cartesian(ylim = c(0.94,0.96)) +
  theme_bw() +
  theme(legend.position = 'bottom') +
  scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +
  facet_wrap(vars(rozklad))
  
```

Eksperymenty przeprowadzone dla tych dwóch rozkładów dają dobre wyniki w okolicy 95% - potwierdza to skuteczność przyjętego sposobu wyznaczania przedziału ufności. Wszystkie odsetki mieszczą się w przedziale 95%+-1%. W tym przypadku nawet mała liczebność próby nie psuje wyników, mimo że możnaby się tego spodziewać w przypadku rozkładu logistycznego ze względu na to, że wyznaczając przedział ufności korzystamy z tego, że średnie dowolnych rozkładów o znanej wariancji i wartości oczekiwanej asymptotycznie dążą do rozkładu normalnego (czyli dla małej próby mogłoby tak nie być).

Wyniki dla rozkładu Cauchy'ego ponownie pokazują, że nie możemy wyznaczać dla niego przedziału ufności w przyjęty sposób. Powodem jest niespełnione założenie Centralnego Twierdzenia Granicznego o istnieniu wariancji i wartości oczekiwanej. Można zauważyć, że odsetek pokrytych parametrów spada wraz ze wzrostem $n$, co potwierdziły dodatkowe doświadczenia - dla większych $n$ był on coraz bliższy 0.

```{r}
zad2.results %>% 
  filter(rozklad == 'rcauchy') %>%
  mutate(params = factor(paste(m1, s1, m2, s2, sep = ', '))) %>%
  group_by(n) %>%
  ggplot(aes(x = n, y = wynik, fill = params)) +
  geom_bar(stat = 'identity', position = position_dodge()) +
  labs(title = 'Zadanie 2 - wyniki dla rozkladu Cauchy\'ego', subtitle = 'Procent roznic srednich pokrytych przez przedzial ufnosci na poziomie 95%', x = 'n', y = '', fill = 'Parametry') +
  scale_fill_brewer(palette="Set1")+
  coord_cartesian(ylim = c(0,0.2)) +
  theme_bw() +
  scale_y_continuous(labels = scales::percent_format(accuracy = 0.1)) +
  theme(legend.position = 'bottom')
```

### Zadanie 3
Tym razem zakładamy, że nie znamy wariancji populacji z których pobrano próby $X_1, X_2$, przy czym wiadomo że są one równe. Ponieważ
