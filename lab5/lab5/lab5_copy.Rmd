---
title: "Statystyka - Laboratorium 5"
author: "Martyna Konopacka"
output: pdf_document  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE, results = 'asis')
knitr::opts_chunk$set(fig.width = 10, fig.height = 5) 
```
```{r}
library(tidyverse)
library(stats)
```


## Wprowadzenie i cele
Rozważmy problem testowania hipotezy $H_0: F = G$ przeciwko $H_1: F \neq G$, gdzie $F,G$ są ciągłymi dystrybuantami nieznanych rozkładów, z których pochodzą próby $X_1, ... X_m; Y_1, ..., Y_n$ - na naszej liście $n = m$. Przyjmujemy, że testy będą prawostronne, na poziomie istotności $\alpha$. Rozważane testy są nieparametryczne - opierają się na statystykach rangowych, przez co mają zastosowanie również do danych innych niż liczbowe, dających się uporządkować.

*Rangą $R_i$* nazwiemy liczbę przyporządkowaną obserwacji poprzez posortowanie wybranej zmiennej. Przykładowo dla $X = (1,7,3,10)$ rangi to $(1,3,2,4)$. Uwaga: dla rosnącego przekształcenia zmiennej losowej rangi pozostają bez zmian - to przyda się w późniejszych rozważaniach. Przykładowo $2X+7 = (9,21,13,27)$ - rangi pozostają takie same.

*Testem* nazwiemy funkcję próby $\varphi(X)$. Na podstawie wartości $\varphi(X)$ podejmujemy decyzję: odrzucamy $H_0$ dla dużych wartosci funkcji.

*Wartość krytyczna* to wartość, która dzieli przestrzeń możliwych wartości statystyki testowej $S(X)$ na dwa podzbiory - dla jednego z nich odrzucamy hipotezę zerową. W tym przypadku będą to przedziały na osi liczb rzeczywistych i hipotezę odrzucimy, gdy $S(X) \geq c$.

#### Jak wyznaczamy wartości krytyczne?
Liczba $\alpha$ reprezentuje prawdopodobieństwo popełnienia błędu typu I, czyli odrzucenia $H_0$, gdy jest ona prawdziwa. 
$$\alpha = P(S(X) \geq c | H_0) = 1 - P(S(X) \leq c | H_0)$$
$$P(S(X) \leq c | H_0) = 1 - \alpha$$
zatem $c = F_S^{-1}(1 - \alpha)$ jest kwantylem rzędu $1 - \alpha$ rozkładu $S(X)$ przy $H_0$. Uwaga: nie znamy prawdziwego rozkładu statystyki testowej przy $H_0$, a jedynie rozkład asymptotyczny.

Celem poniższego raportu jest wyznaczenie wartości krytycznych oraz zbadanie zachowania funkcji mocy w zależności od parametrów populacji dla testów: Wilcoxona (W), Ansari-Bradley'a (AB), Lepage'a (L) i Kołmogorowa-Smirnowa (KS).

## Zadanie 1
Zadanie 1 stanowi wstęp do kolejnych zadań - problem został zawężony do rozkładu normalnego. W tym zadaniu zajmiemy się tylko obliczaniem wartości krytycznych. Na początek zdefiniujemy odpowiednie statystyki:

```{r echo=TRUE}
# implementacja wzoru (2) z listy; oblicza wartość statystyki T dla wybranej funkcji (testu) phi i połączonych prób X,Y;
# funkcja rank(X) zwraca wektor rang obliczonych dla wektora X
T_phi <- function(phi, X, Y){
  Z <- c(X, Y)
  m <- length(X)
  n <- length(Y)
  N <- n + m
  s <- sqrt(m * n / N)
  m1 <- mean(phi((rank(Z)[1:m] - 0.5)/N))
  m2 <- mean(phi((rank(Z)[(m+1):N] - 0.5)/N))
  return (s * (m1 - m2))
}

# implementacja funkcji (testów) phi1, phi2 z listy
phi1 <- function(u){sqrt(3)*(2*u - 1)}
phi2 <- function(u){sqrt(48)*(0.25 - abs(u - 0.5))}

# statystyki zdefiniowane na liście
W <- function(X, Y){T_phi(phi1, X, Y)^2}
AB <- function(x, y){T_phi(phi2, X, Y)^2}
L <- function(X, Y){W(X, Y) + AB(X, Y)}
KS <- function(X, Y){
  Z <- c(X, Y)
  m <- length(X)
  n <- length(Y)
  N <- n + m
  s <- sqrt(m*n/N)
  # return (ks.test(X,Y)$statistic) # to jest bez czynnika z pierwiastkiem
  return (s * ks.test(X, Y)$statistic) # zwróć wartość obliczoną przez funkcję ks.test odpowiadającą supremum we wzorze z listy
}
```

Z użyciem powyższych funkcji generujemy wyniki. 

```{r echo=FALSE}
M <- 20 # użyty rozmiar próby
A <- matrix(0, 10000, 4) # macierz z wynikami; wiersze to kolejne iteracje, kolumny
set.seed(1)
for (i in 1:10000){
  X <- rnorm(M, 0, 1)
  Y <- rnorm(M, 0, 1)
  A[i, 1] <- W(X, Y)
  A[i, 2] <- AB(X, Y)
  A[i, 3] <- L(X, Y)
  A[i, 4] <- KS(X, Y)
}
# colnames(A) <- c('W','AB','L','KS')
# head(A) %>% knitr::kable(caption = 'Pierwsze wiersze macierzy z wynikami eksperymentu - obliczone wartości statystyk')
```

```{r}
cW <- quantile(A[, 1], 0.95)
cAB <- quantile(A[, 2], 0.95)
cL <- quantile(A[,3], 0.95)
cKS <- quantile(A[,4], 0.95)

# z jakiegoś powodu ma tak być?
# c(cW, qchisq(0.95, 1))
# c(cAB, qchisq(0.95, 1))
# c(cL, qchisq(0.95, 2))

c(W = cW, AB = cAB, L = cL, KS = cKS) %>% 
  knitr::kable(caption = 'Wartosci krytyczne; n = m = 20')
```

```{r}
M <- 50 # użyty rozmiar próby
A <- matrix(0, 10000, 4) # macierz z wynikami; wiersze to kolejne iteracje, kolumny
set.seed(1)
for (i in 1:10000){
  X <- rnorm(M, 0, 1)
  Y <- rnorm(M, 0, 1)
  A[i, 1] <- W(X, Y)
  A[i, 2] <- AB(X, Y)
  A[i, 3] <- L(X, Y)
  A[i, 4] <- KS(X, Y)
}

cW <- quantile(A[, 1], 0.95)
cAB <- quantile(A[, 2], 0.95)
cL <- quantile(A[,3], 0.95)
cKS <- quantile(A[,4], 0.95)

# z jakiegoś powodu ma tak być?
# c(cW, qchisq(0.95, 1))
# c(cAB, qchisq(0.95, 1))
# c(cL, qchisq(0.95, 2))
# c(cKS, qKS())

c(W = cW, AB = cAB, L = cL, KS = cKS) %>% knitr::kable(caption = 'Wartosci krytyczne; n = m = 50')
```

## Zadanie 2
